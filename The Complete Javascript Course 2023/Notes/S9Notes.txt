L101 Section Intro:
    Will cover:
        1. Built-in data structures like objects, maps, and arrays
        2. Modern ES6+ operators like destructuring nad optional chaining
        3. How to work with strings

L102 Section Roadmap


L103 Destructuring Arrays:
    Destructuring (ES6) - Way of unpacking of values in an array or object into separate variables. (Break a complex data structure down into a simpler data structure like a variable)

    In VS Code, you can duplicate selection
    
    Simple way to destructure an array:
        const ['var 1', var 2', etc...] = 'array name'

        Destructuring assignment assigns leftmost variables starting from index 0

        Can also skip an index with an empty space like this:
            const ['var 1', ,'var 2'] = 'array name'

    Destructuring also allows us to easily switch variable values:
        ['var 1', 'var 2'] = ['var 2', 'var 1']

    You can destructure arrays returned from functions

    You can also destructure nested arrays used nested destructuring:
            const ['var 1', [var 2', 'var 3'], etc...] = 'array name'

    We can set default values for the variables when we are destructuring/extracting them:
        const ['var 1' = 'default value 1', 'var 2' = 'default value 2', etc...] = 'array name'

        
        Useful for when we do not know the length of the array

    Destructuring an array for a non existant index returns an undefined


L104 Destructuring Objects
    Similar to destructuring arrays, except key differences:
        const {'property 1', property 2', etc...} = 'object name'

        Objects are unordered so do not need to skip, however need to specify the exact property name as the variable name

        Extremely useful for dealing with API call results

    Can specify variable names in destructuring objects:
        const {'property 1': 'variable 1', property 2': 'variable 2', etc...} = 'object name'

    Cam also specify default values in destructuring objects:
        const {'property 1' = 'default value 1', property 2' = 'default value 2', etc...} = 'object name'

    Mutating variables with object destructuring:
        We can't just do:
            {'property 1', 'property 2'} = 'object name'
        since JS expects this to be a code block, and we cannot assign to a code block as it will create a SyntaxError

        To propertly reassign variables using destructuring objects, need to wrap the entire statement in parentheses:
            ({'property 1', 'property 2'} = 'object name')

    Nested Objects:
        Similarly, we can specify and destructure nested objects:
            const {'nested object name' : {'property name 1', 'property name 2', etc...} = 'object name'

    You can define objects as parameters for a function:
        This is useful for functions with many multiple parameters as you don't have to keep track of the parameter order, and destructure the object right away in the function parameters

        'object name' = {'property 1', 'property 2', etc..}
        'function name' = function ({'property 1', 'property 2', etc..}) {
            "function body"
        }
        'function name' ({'property 1', 'property 2', etc..});


L105 The Spread Operator (...):
    We can use the spread operator to expand an array into all its elements, unpacking all the array elements at once

    Spread Operator (ES6) - Takes all the values out of an array, and writes the values individually in sequence
        ...'array name'

        Spread operator creates expressions with the array values and commas in between, which does not create new variables by itself, and is used specifically within arrays:
        ...'array name' === `val1, val2, ... , etc`
    
    We create new arrays using Array Literal Syntax to declare and copy an array with a spread operator

    Two use cases for the Spread Operator are:
        1. Create shallow copies of arrays (similar to object.assign)
        2. Merge two arrays together

    The spread operators works on all iterables, which are data structures like arrays, strings, maps, or sets BUT NOT objects (unles ES2018+)

    You cannot use the spread operator in template literals because this is not a place where it expects multiple values separated by a comma; this is only expected when passing arguments to a function or building a new array

    use '\' to escape characters from string for example

    In (ES2018+), spread objects DO WORK on objects even though they are not iterables, and can be used to pass object property:value pairs to create new object copys:
        const 'new object name' === { 'new property': 'value', ...'object name', etc.. }


L106 Rest Pattern and Parameters
    Rest Patterns use same syntax as spread operators but does the opposite by collecting multiple elements, and condensing them into an array 

    Rest Patterns (ES6) - Takes the rest of the elements, and puts them into an array:
        const ['var 1', 'var 2', ...'var 3'] = 'array name'

        Rest element must be the very last element / There can only be one est element in a destructuring assignment

        Does not include any skipped elements in the destructuring

    Also works in objects (ES2018+):
        const {'property 1', 'property 2', ...'rest variable name'} = 'object name'

    We can also use the rest parameters to implement the opposite of spread operator to pass any number of arguments (in an array) to a function parameter:
        const 'function name' = function (...'rest parameter name') { "function body" }

        This useful so that a function can take both an array and all single values extract from a spread operator simultaneously

        Also feels more natural, and used frequently

        If there are no rest arguments, the rest parameter returns an empty array

    So the spread operator is used where we would write values (or object property:value pairs) separated by a comma, and the rest pattern is used where we would write variable names separated by commas


107 Short Circuiting (&& and ||)
    Logical Operators are limited to boolean types, so they can:
        1. Use ANY data type
        2. Return ANY data type
        3. Short-circuit Evaluation / Short-circuiting

    Short-circuiting - It will evaluate for the first expression, and short-circuit the rest of the evaluation:
        ||: It will evaluate the expression until the first truthy value, then return that value. If all the values are falsy, then it will return the last value even if the last value is falsy as well

        &&: It will evaluate the expresion an the first falsy value, the return that value. If all value are true, then it will return the last v alue even if the last value is truthy as well

        Useful for replacing ternary operators (for longer evaluations) and if / else statements:
            Useful to use || to set default values and && to execute code in the second operand if the first operand is true        


L108 The Nullish Coalescing Operator (??)
    Nullish Coalescing Operator:
        ??: Similar to || but it instead works with concept of nullish values ('null' abd 'undefined'). It will evaluate the expression for the first non-nullish value, and short-circuit/return it. Otherwise, it will return the last value even if it is nullish.

        Basically, it is || if 0 and '' were treated as truthy values