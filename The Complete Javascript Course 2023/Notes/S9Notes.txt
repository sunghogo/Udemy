L101 Section Intro
    Will cover:
        1. Built-in data structures like objects, maps, and arrays
        2. Modern ES6+ operators like destructuring nad optional chaining
        3. How to work with strings

L102 Section Roadmap


L103 Destructuring Arrays
    Destructuring (ES6) - Way of unpacking of values in an array or object into separate variables. (Break a complex data structure down into a simpler data structure like a variable)

    In VS Code, you can duplicate selection
    
    Simple way to destructure an array:
        const ['var 1', var 2', etc...] = 'array name'

        Destructuring assignment assigns leftmost variables starting from index 0

        Can also skip an index with an empty space like this:
            const ['var 1', ,'var 2'] = 'array name'

    Destructuring also allows us to easily switch variable values:
        ['var 1', 'var 2'] = ['var 2', 'var 1']

    You can destructure arrays returned from functions

    You can also destructure nested arrays used nested destructuring:
            const ['var 1', [var 2', 'var 3'], etc...] = 'array name'

    We can set default values for the variables when we are destructuring/extracting them:
        const ['var 1' = 'default value 1', 'var 2' = 'default value 2', etc...] = 'array name'

        
        Useful for when we do not know the length of the array

    Destructuring an array for a non existant index returns an undefined


L104 Destructuring Objects
    Similar to destructuring arrays, except key differences:
        const {'property 1', property 2', etc...} = 'object name'

        Objects are unordered so do not need to skip, however need to specify the exact property name as the variable name

        Extremely useful for dealing with API call results

    Can specify variable names in destructuring objects:
        const {'property 1': 'variable 1', property 2': 'variable 2', etc...} = 'object name'

    Cam also specify default values in destructuring objects:
        const {'property 1' = 'default value 1', property 2' = 'default value 2', etc...} = 'object name'

    Mutating variables with object destructuring:
        We can't just do:
            {'property 1', 'property 2'} = 'object name'
        since JS expects this to be a code block, and we cannot assign to a code block as it will create a SyntaxError

        To propertly reassign variables using destructuring objects, need to wrap the entire statement in parentheses:
            ({'property 1', 'property 2'} = 'object name')

    Nested Objects:
        Similarly, we can specify and destructure nested objects:
            const {'nested object name' : {'property name 1', 'property name 2', etc...}} = 'object name'

    You can define objects as parameters for a function:
        This is useful for functions with many multiple parameters as you don't have to keep track of the parameter order, and destructure the object right away in the function parameters

        'object name' = {'property 1', 'property 2', etc..}
        'function name' = function ({'property 1', 'property 2', etc..}) {
            "function body"
        }
        'function name' ({'property 1', 'property 2', etc..});


L105 The Spread Operator (...)
    We can use the spread operator to expand an array into all its elements, unpacking all the array elements at once

    Spread Operator (ES6) - Takes all the values out of an array, and writes the values individually in sequence
        ...'array name'

        Spread operator creates expressions with the array values and commas in between, which does not create new variables by itself, and is used specifically within arrays:
        ...'array name' === `val1, val2, ... , etc`
    
    We create new arrays using Array Literal Syntax to declare and copy an array with a spread operator

    Two use cases for the Spread Operator are:
        1. Create shallow copies of arrays (similar to object.assign)
        2. Merge two arrays together

    The spread operators works on all iterables, which are data structures like arrays, strings, maps, or sets BUT NOT objects (unles ES2018+)

    You cannot use the spread operator in template literals because this is not a place where it expects multiple values separated by a comma; this is only expected when passing arguments to a function or building a new array

    use '\' to escape characters from string for example

    In (ES2018+), spread objects DO WORK on objects even though they are not iterables, and can be used to pass object property:value pairs to create new object copys:
        const 'new object name' === { 'new property': 'value', ...'object name', etc.. }


L106 Rest Pattern and Parameters
    Rest Patterns use same syntax as spread operators but does the opposite by collecting multiple elements, and condensing them into an array 

    Rest Patterns (ES6) - Takes the rest of the elements, and puts them into an array:
        const ['var 1', 'var 2', ...'var 3'] = 'array name'

        Rest element must be the very last element / There can only be one est element in a destructuring assignment

        Does not include any skipped elements in the destructuring

    Also works in objects (ES2018+/ES9+):
        const {'property 1', 'property 2', ...'rest variable name'} = 'object name'

    We can also use the rest parameters to implement the opposite of spread operator to pass any number of arguments (which is then packed into an array) as a function parameter:
        const 'function name' = function (...'rest parameter name') { "function body" }

        This is useful so that a function can take both an array (using a spread operator) and all single values extract from a spread operator simultaneously

        Also feels more natural, and used frequently

        If there are no rest arguments, the rest parameter returns an empty array

    So the spread operator is used where we would write values (or object property:value pairs) separated by a comma, and the rest pattern is used where we would write variable names separated by commas


107 Short Circuiting (&& and ||)
    Logical Operators are limited to boolean types, so they can:
        1. Use ANY data type
        2. Return ANY data type
        3. Short-circuit Evaluation / Short-circuiting

    Short-circuiting - It will evaluate for the first expression, and short-circuit the rest of the evaluation:
        ||: It will evaluate the expression until the first truthy value, then return that value. If all the values are falsy, then it will return the last value even if the last value is falsy as well

        &&: It will evaluate the expresion until the first falsy value, then return that value. If all value are true, then it will return the last value even if the last value is truthy as well

        Useful for replacing ternary operators (for longer evaluations) and if / else statements:
            Useful to use || to set default values and && to execute code in the second operand if the first operand is true        


L108 The Nullish Coalescing Operator (??)
    Nullish Coalescing Operator (ES2020+/ES11+):
        ??: Similar to || but it instead works with concept of nullish values ('null' abd 'undefined'). It will evaluate the expression for the first non-nullish value, and short-circuit/return it. Otherwise, it will return the last value even if it is nullish.

        Basically, it is || if 0 and '' were treated as truthy values


109 Logical Assignment Operators
    Logical Assignment Operators (ES2021+/ES12+):
        Logical OR Assignment Operator -
            ||=: Assigns the value in the second operand to the first operand if the value in the first operand is falsy

        Logical Nullish Assignment Operator =
            ??=: Assigns the value in the second operand to the first operand if the value in the first operand is a nullish value

        Logical AND Assignmer Operator -
            &&=: Assigns the value in the second operand to the first operand if the value in the first operand is a truthy value

        Useful for shorthand way of assigining variable using logical operators

        Assigning properties that did not exist as 'undefined' does not change the object, and the property will not show up/remain undefined


L110 Coding Challenge #1


L111 Looping Arrays: The for-of Loop
    for-of loop (ES6+) - it will automatically loop over the entire array, and give us access to the current element at each iteration:
        for (const 'iteration variable' of 'array') { "loop body"}

    for-of loops are still able to use continue and break

    Do not need code blocks for conditional and loop statements if there is only one line to execute

    .entries() array method returns an Array Iterator, which is an array with elements that are also arrays that contain ['index number', 'element at that index']

 You can use for-of loop on an 'array'.entries() to also be able to access its index numbers


L112 Enhanced Object Literals
    ES6 introduced three ways to make writing Object Literal Syntax easier:
        1. If you are storing outside variables as same name properties, you can just declare the property name without the value assignment:
            const obj = "..."/{"..."}
            const obj2 = {
                obj,
            }
        2. You can assign functions as a property without the function keyword and value assignment (aka without a function expression):
            const obj = {
                'function name'('parameter') {
                    "functon body"
                },
            }
        3. You can compute property names (use expressions) instead of writing them out literally:
            const obj = {
                ("expression"): 'value'
            }

    Before you could only use expressions when assigning property values, but now you can do it for property names as well (as long as it outputs a single string)


L113 Optional Chaining (?.)
    For deeply nested objects, if we were to check for whether every object property exists, it would easily get out of hand and easier to create bugs
    
    Optional Chaining (ES2020+/ES11+) - If a certain property or element does not exist (aka nullish property of being 'undefined'/'null'), then undefined is returned immediately:
        'object name'.'property'.'property 2'?.'property 3'

        'object name'.'method'?.('parameters')
        ?? "Method does not exist"

        It can also be used to access objects inside of arrays:
            'array name'['index']?.'property name' ?? 'User array empty'

        The '?' chaining operator checks if that property exists, and if it doesn't, short-circuits and returns undefined

        It can be used for object methods as well, and should be paried with the null coalescing operator to return default values if it does not exist

    Remember if we want to use a variable as the property name, we must use the bracket notation as it makes a distinction between variables and string literals:
        'object name'['variable for property name']

    Useful for Web APIs