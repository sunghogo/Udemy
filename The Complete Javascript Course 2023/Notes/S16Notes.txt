L244 Section Intro


L245 Section Roadmap


L246 Asynchronous JavaScript, AJAX and APIs
    Synchronous:
        Most code is Synchronous
        
        Synchronous code is executed Line by Line

        Thread of Execution:
            Part of execution context that actually executes the code in the computer's CPU

        Each line of code waits for previous line to finish;

        Long-running operations BLOCK code execution

    Asynchronous:
        Asynchronous code is executed AFTER a task that runs in the "background" finishes

        Asynchronous code is NON-BLOCKING

        Execution doesn't wait for asynchronous task to finish its work

        Asynchronous programming is coordinating behavior of a program over a period of time

        Callback functions alone do NOT make code asynchronous!

        .addEventListener does NOT automatically make code asynchronous! (since there is no asynchronous behavior at all)

    AJAX:
        Asynchronous JavaScript And XML (AJAX): Allows us toc communicate with remote web servers in an ASYNCHRONOUS way. With AJAX calls, we can REQUEST DATA from web servers dynamically.

        CLIENT (e.g browser) REQUEST (GET / POST / etc.) data from WEB SERVER (usually web API) that sends data back in RESPONSE

    API:
        Application Programming Interface: Piece of software that can be used by another piece of software, in order to allow APPLICATIONS to TALK to EACH OTHER

        There are many types of APIs in web development:
            DOM API, Geolocation API, Own Class API, "Online" API (Just "API")
        
        "Online" API: Application running on a server, that receives requests for data, and sends data back as response

        We can build OUR OWN web API's (requires back-end development, e.g. with node.js) or use 3rd-party APIs

        There is an API for everything:
            - Weather data
            - Data about countries
            - Flights data
            - Currency conversion data
            - APIs for sending email or SMS
            - Google Maps
            - Millions of possibilites...
    
    AJAX:
        XML is a data format that was popular in the past but is no longer used

        JSON data format is the most popular API data format (since it is basically a JS object converted to a string)


L247 IMPORTANT: API URL Change
    API URL Changed from:
        https://restcountries.eu/rest/v2/
    To:
        https://restcountries.com/v2/

        https://restcountries.com/v3.1/

    Public APIs:
        https://github.com/public-apis/public-apis

        Should have no authentication, HTTPS set to YES, and Cross Origin Resource Sharing (CORS) set to YES/Unknown 

        Search API Endpoint to look for URL


L248 Our First AJAX Call: XMLHttpRequest
    new XMLHttpRequest() constructor function is the old school way of doing AJAX calls:
        .open('HTTP request type', 'URL') method opens the request to the specified Endpoint

        .send() method sends the request asynchronously

        .addEventListener('load', 'callback function' {
            const [data] = JSON.parse(this.responseText)
        }) 
        is used to retrieve the response that is sent back ('this' refers to the response, while .responseText is the property containing the data in JSON)

        JSON.parse() function to turn the retrieved data into an array of objects

    Having multiple AJAX calls in parallel (happening at the same time) will have different order when the data arrives


L249 [OPTIONAL] How the Web Works: Requests and Responses
    Request-response model or Client-server architecture:
        CLIENT (e.g browser) REQUEST (GET / POST / etc.) data from WEB SERVER (usually web API) that sends data back in RESPONSE

        Client:
            https://restcountries.eu/rest/v2/alpha/PT
            
                Protocol (HTTP or HTTPS): 'https://'
                Domain name: 'restcountries.eu'
                Resource '/rest/v2/alpha/PT'

            Steps:
                1. Domain Name Server - A special server that acts like a phonebook for IP addresses
                    DNS lookup to find the real IP address of a domain name

                    https://104.27.142.889.443

                        Protocol (HTTP or HTTPS): 'https://'
                        IP address: '104.27.142.889'
                        Port number (Default 443 for HTTPS. 80 for HTTP): '.443'

                2. Transmission Control Protocol (TCP)/Internet Protocol (IP) socket connection is established between the browser and web server
                    Connection is kept alive until all files of a website or all data has been transferred

                    TCP/IP together are communication protocols that define how data travels accross the internet (Internet's fundamental control system)

                3. Hypertext Transfer Protocol (HTTP) request is made from the browser to the web sever:
                    HTTP is another communication protocol (a system of rules that allows two or more parties to communicate)

                    HTTP allows clients and web servers to communicate by sending requests and response messages from clients to servers and back

                    HTTP Request Message:
             
             
                        GET /rest/v2/alpha/PT HTTP/1.1

                        Host: www.google.com
                        User.Agent: Mozilla/5.0
                        Accept-Language: en-US

                        <BODY>

                        Start line: HTTP method + request target + HTTP version
                            HTTP methods:
                                1. GET - for reuqesting data
                                2. POST - for sending data
                                3. PUT / PATCH - to modify data
                            Request target: Where the server is told where to access the specific resource
                        
                        HTTP request headers (many different possibilites):
                            Information sent about the request itself

                        Request body (only when sending data to server e.g. POST):
                            Contains the data that were sending (e.g. data from HTML form)
            
            Web Server:
                4. HTTP response is used to send data back to the browser from the server:

                    HTTP Response Message:

                        HTTP/1.1 200 OK

                        Date:Fri, 18 Jan 2021
                        Content-Type: text/html
                        Tranfer-Encoding: chunked

                        <BODY>

                        Start line: HTTP version + status code + status message
                            Status code and message - Used to let client know the request is ok (e.g. 200 is ok, 404 is failed)
                        
                        HTTP response (many different possibilities):
                            Information about the response itself

                        Response body (mostly response):
                            Usually contains JSON data from API or html of website

                5. Arrives back to client/web browser:
                    1. index.html is first to be loaded
                    2. Scanned for assets: JS, CSS, images
                    3. Process is repeated for each file

        HTTPS is encrypted using TLS or SSL, some more encryption protocols while HTTP is not

        TCP/IP:
            TCP breaks requests and responses down into small chunks of data called packets:
                This is necessary so each packet can take a different route through the internet, and arrive faster
            
            The role of IP is send and route all the packets through the internet to the correct destination using IP address on each packet 

            Once all the small packets arrive at the final destination, TCP reassemble all packets into the original request or response


L250 Welcome to Callback Hell
    The order of multiple AJAX calls running in parallel can be controlled using nested AJAX callbacks

    "Callback hell" is when there are a lot nested callbacks in order to complete asynchronous task synchronously:
        Makes the code very messy, difficult to maintain, and difficult to reason about -> BAD CODE


L251 Promises and the Fetch API
    The Fetch API is the modern way of making AJAX calls:
        fetch('Endpoint URL')

        returns a Promise object

    Promise (ES6/ES2015):
        Promise - An object that is used as a placeholder for the future result of an asynchronous operation
        ->
        Promise - A container for an asynchronously delivered value
        ->
        Promise - A container for a future value (Example: Response from AJAX call)

        Two advantages:
            1. We no longer need to rely on events and callbacks passed into asynchronous functions to handle asynchronous results

            2. Instead of nesting callbacks, we can chain promises for a sequence of asynchronous operations: escaping callback hell

    Since promises work with asynchronous operations they are time sensitive so promises can be in different states

    Promise Lifecycle:
        1. Pending - Before the future value is available
        Async Task ->
        2. Settled - Asynchronous task has finished
        3.  Fulfilled - Success! The value is now available
            Rejected - An error happened

        We are able handle these different states in our code!

        Also promises are only settled once, and the state remains unchanged forever

        Build Promise - (e.g Fetch API returns promise)
        ->
        Consume Promise - When we already have a promise (e.g. promise returned from Fetch API)


L252 Consuming Promises
    The fetch('Endpoint URL') returns a promise that returns a response object when it resolves

    .then('callback function'('response object') { "callback function body" }) Promise method takes in one parameter, which is a callback function which also gets the resulting response object passed into it as an argument:
        All resolved response object also has a .json() method avaiable that is also an asynchronous function that returns a promise with the response object containing the JSON data

    So, 
        1. The fetch() method returns a promise, which is handled by the first .then() method 
        2. The first .then() method's callback function calls the asynchronous .json() method on the resolved response object, returning a new promise
        3. The second .then() method is then called on the new promise, which resolves to the actual JSON data

    Promises don't get rid of callbacks, but gets rid of callback hell and leads to more concise code