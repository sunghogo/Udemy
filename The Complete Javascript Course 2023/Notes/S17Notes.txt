L268 Section Intro


L269 Section Roadmap


L270 An Overview of Modern JavaScript Development
    Modern JavaScript Development:
        Development: 
            We now divide our project into multple modules to make our project more organized and maintainable:
                Before we used to divide into multiple scripts and send them
            
            Can include 3rd-party modules

            Node Package Manager(NPM):
                Originally developed for Node.js, but is now the go to repository for all kinds of packages in modern JS development 
 
                Contains open-source packages to include 3rd-party code in our own code (e.g React, jQuery, Leaflet, etc.)

                NPM is both repository in which packages lives, and the program we use on the computer to install and manage these packages

        Build Process:
            One big JS bundle is built which will deployed to the web server for production

            Bundling - Joins all the modules into one file:
                Important for two reasons:
                    1. Older browsers don't support modules
                    2. Better for performance to send less files, and bundling step compresses the code

            Transpiling/Polyfilling - Convert modern JS back to ES5:
                Transpiling - Converts code writtern in (newer) ES versions to other (older) ones

                Polyfilling - Implements features in JS that is unavailable in the current JS environment; Commonly used for features that can't be transpiled

                Usually done using a tool called Babel

            We don't do the build process ourselves, and use build tools:
                Webpack and Parcel are the common "JS Bundlers" developer tools:
                    Webpack is the more popular one but can be more configuration intensive

                    Parcel is 0 configuration and requires no setup code

                These development tools are also on NPM

        Production: 
            Production means the application is used by real users in the real world

        Development -> Build Process -> Production


L271 An Overview of Modules in JavaScript
    Module: 
        Resuable piece of code that encapsulates implementation details

        Usually a standalone file, but it doesn't have to be

        We can import ("Dependency") and export ("Public API") module code 

        Module Benefits in Software Design:
            1. Compose software: Modules are small building blocks that we put together to build complex applications

            2. Isolate components: Modules can be developed in isolation without thinking about the entire codebase

            3. Abstract code: Implement low=level code in modules and import these abstraction into other modules

            4. Organized code: Modules naturally lead to a more organized codebase

            5. Reuse code: Modules allow us to easily reuse the same code, even across multiple projects
    
    Native JavaScript (ES6) Modules:
        Modules stored in files, exactly one module per file

        ES6 Module:
            1. Top-level variables: Scoped to module (so can only be seen by exported)
            2. Default Mode: Strict mode
            3. Top-level this: undefined
            4. Imports and exports: YES
            5. HTML lnking: <script type="module">
            6. File downloading: Asynchronous

        Script:
            1. Top-level variables: Global
            2. Default Mode: "Sloppy" mode
            3. Top-level this: window
            4. Imports and exports: NO
            5. HTML lnking: <script>
            6. File downloading: Synchronous (unless we use async or defer attributes on script tag)


        imports and exports can only happen at the top-level

        imports are hoisted

    How ES6 Modules are imported:
        Parsing the main script (read the code without execution) is when imports are hoisted:
            Import Modules Before Execution:
                Modules are imported SYNCHRONOUSLY (as in, the main script is only executed AFTER all the imported modules are downloaded and executed)

                Possible thanks to top-level ("static") imports, which makes imports known BEFORE execution

                This makes bundling and dead code elimination possible
        ->
        ASYNCHRONOUS downloading of modules (but run synchronously)
        ->
        Linking imports of main script to module exports ("live connection" so that exported values are NOT COPIED to imports, but imports are reference to the exported values):
            Other modules systems cannot affect imported module values like this, but JS does
        ->
        Execution of modules
        ->
        Execution of main script


L272 Exporting and Importing in ES6 Modules
    For module files, it's convention to using camelcase names

    Importing modules:
        import 'module path':
            './' path is relative to the module file that is importing, not the HTML file

            If we want to import modules in a JS file, then we have specify in HTML that the JS file is of <script type="module" src="JS file path"></script>

        Code in all the modules that are imported is parsed and executed first

        Import statements are hoisted to the top

        All modules are executed in "use strict" mode by default

        All variables declared inside a module are scoped to this module, and all top-level variables are private (unlike scripts)

    Exporting modules:
        Two types of exports:
            1. Named exports - specify/name exports
            2. Default exports - export only one (default) thing per module

        export 'variable/function/etc... declaration'
        OR
        export {'export name 1', 'export name 2', etc...}:
            Need to be followed up in the importing module:
                import {'variable/function/etc... name'} from 'imported module path'

            exports are typically listed at the end of the module

            exports can only happen in top-level code (and not nested in blocks)

    'as' keyword can be used to set a different name to the variables/functions from BOTH import and export statements

    '*' can be used to import or export everything:
        import/export * as 'namespace object name' (from 'module path')

        import * can be specified into a namespace object using 'as':
            Imports has to be referenced as a property/method of the specified namespace

    Exporting modules are basically exporting like a public API, just like a class

    'default' keyword is used to specify the one VALUE that we want to export:
        export default 'expression'

        import 'any name' from 'imported module path'

        Since there is only one default value exported, we can specify it using any name without {}

    You can mix multiple named and default imports/exports, but in practice this is not done due to messy code

    The preferred style is to use one default export per module, but this is not a rigid rule

    Exports are live connections, so imports are NOT copies of the original variables and objects of the exports:
        Mutating them in the import module also mutates them in the export modules since imports are pointers to the same placein memory of the exports

