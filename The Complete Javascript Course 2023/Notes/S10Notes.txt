L126 Section Intro


L127 Section Roadmap


L128 Default Parameters
    Before ES6, would have to specify default values for function parameters separately using the undefined falsy values and logical assignment using ||

    Default Parameters (ES6) - You can now set default values for paramters in the function declaration:
        function 'function name' ('paramter 1' =  'default value', etc..) { "function body" }

        The default paramters can be expressions, but the order of parameter declaration matters

        You cannot skip arguments, but what you can do is set them to udnefined, which is practically the same


L129 How Passing Arguments Works: Value vs. Reference
    Generally speaking, it is not good practice to change the argument value

    When we pass a primitive type as an argument to a function, it creates a copy of that original value and not the actual original value in the stack

    When we pass a reference type as an argument to a function, the copy is just the reference to the object in heap memory, so both the original value and argument reference and manipulate the same object

    In large codebases, this behavior by objects can have consequences and introduce bugs

    Scientific notation can be implmeented like this:
        1 * 10 ** 6 === 1 * e+6

    Two terms for passing arguments in JS:
        1. Passing by reference - You can pass a reference to any value instead a value itself (ex. pointers in C++)

        2. Passing by value - You pass the value itself and not the reference (even in JS, we pass a value that is a memory address of an object, and not a reference itself)

        JS does NOT have passing by reference, only passing by value


L130 First-Class and Higher-Order Functions
    First-Class Functions:
        JS treats functions as first-class citizens

        This means that functions are simply values

        Functions are just another "type" of object
    
    Since JS treats functions are first-class, they have interesting properties:
         1. Store functions in variables or object properties
         2. Pass functions as arguments to OTHER functions (ex. .addEventListener())
         3. Return functions FROM functions
         4. Call methodson functions (ex. .bind())

    Higher-Order Functions:
        A function that RECEIVES another function as an argument, that RETURNS a new function, or BOTH

        This is only possible because of first-class functions

        Types:
            1. Function (Higher-order function) that receives another function (Callback function) (ex. addEventListener())

            2. Functions (Higher-order functions) that returns new function (Returned functions)

    First-class functions is just a feature that a programming language has or doesn't have, a concept that all functions are values and not the practical application

    Higher-order functions are in practice possible due to first-class function support

    Callback funciions are named that way because we do not call themselves, but call JS to tell them later

L131 Functions Accepting Callback Functions
    When we're passing in callback functions as arguments, we are passing in the function WITHOUT calling it (without the ())

    .name is a function property that gives the function name

    .forEach('callback function name') is a array method, where you can pass in a callback function that executes for each element in the array

    Callback functions allows us to:
        1. Split our code into more reusable and interconnected parts
        2. They allow us to create abstractions (hide the details of code implementation, and allows us think about problems at a higher abstraction level)

L132 Functions Returning Functions
    Higher-order functions are able to pass down its arguments to lower-order functions due to "closure":
        'higher-order function name'('paramter')('returned function paramter')

    Functions returning other functions is extremely useful for functional programming paradigm

    For declaring higher-order functions, you can used nested arrow functions:
        const 'higher-order function name' = ('paramter') => ('nested parameter') => { "function body" }

        Remember, arrow functions has no 'this' and 'arguments' keyword